<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>


// -створити класс попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт класу "принц" за допомоги класу який має поля ім'я, вік, туфелька яку він знайшов.
// -- за допоиоги циклу знайти яка попелюшка повинна бути з принцом

    //     class Human {
    //         constructor(name, age) {
    //             this.name = name || 'No Name'
    //             this.age = age || 'No age'
    //         }
    //     }

    //     class Cinderella extends Human {
    //         constructor(name, age, footSize) {
    //         super(name, age);
    //         this.footSize = footSize || 'No FootSize'
    //      }
    //  }   
    //     class Prince extends Human {
    //         constructor(name, age, shoeSize) {
    //         super(name, age);
    //         this.shoeSize = shoeSize || 'No ShoeSize'
    //      }
    //      findCinderell(array) {
    //         let find = null;
    //         for (const item of array) {
    //             if (item.footSize === this.shoeSize) {
    //                 find = item;
    //             }
    //         }
    //         if (find) {
    //             console.log('My cinderalla name ' + find.name);
    //         } else {
    //             console.log('I am not find my cinderell');
    //         }
    //      }
    //  }   

    //  let cinderella1 = new Cinderella('Anna', 18, 36);
    //  let cinderella2 = new Cinderella('Nastya', 19, 36.5);
    //  let cinderella3 = new Cinderella('Olga', 25, 37);
    //  let cinderella4 = new Cinderella('Lilya', 24, 37.5);
    //  let cinderella5 = new Cinderella('Tania', 19, 38);
    //  let cinderella6 = new Cinderella('Nana', 25, 38.5);
    //  let cinderella7 = new Cinderella('Shiki', 26, 39);
    //  let cinderella8 = new Cinderella('Kira', 28, 39.5);
    //  let cinderella9 = new Cinderella('Dosia', 30, 40);
    //  let cinderella10 = new Cinderella('Klava', 29, 41);

    //  let arrayCinderells = [cinderella1, cinderella2, cinderella3, cinderella4, cinderella5, cinderella6, cinderella7, cinderella8, cinderella9, cinderella10];

    //  const prince = new Prince('Ivan', 19, 40);
    //  prince.findCinderell(arrayCinderells);


// -створити функцію конструктор попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт типу "принц" за допомоги функції конструктора з полями ім'я, вік, туфелька яку він знайшов, та функцію "пошук попелюшки"
// -- функція повинна приймати масив попелюшок, та шукає ту котра йому підходить

    // function Cinderella (name, age, footSize) {
    //     this.footSize = footSize || 'No FootSize'
    //     this.name = name || 'No name'
    //     this.age = age || 'No age'   
    // }     
    
    // function Prince (name, age, shoeSize) {
    //     this.shoeSize = shoeSize || 'No ShoeSize'
    //     this.name = name || 'No name'
    //     this.age = age || 'No age'

    //     this.findCinderell = function(array) {
    //         let find = null;
    //         find = array.find(item => item.footSize === this.shoeSize);
    //         find ? console.log('My cinderalla name ' + find.name) : console.log('I am not find my cinderell');
    //     }
    // }
    




// Створити функцію конструктор для об'єкту який описує теги
// Властивості
//  -назва тегу
//  - опис його дій
//  - масив з атрибутами (2-3 атрибути максимум)
//  Кожен атрибут описати як окремий який буде містити
//  -назву атрибуту
//  -опис дії атрибуту
//  інформацію брати з htmlbook.ru

//  Таким чином описати теги
//  -a
//  -div
//  -h1
//  -span
//  -input
//  -form
//  -option
//  -select

// Приклад результуючого об'єкту
//    {
//         titleOfTag: 'area',
//         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
//         attrs: [
//         {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
//         {/*some props and values*/},
//         {/*...*/},
//         {/*...*/},
//         ]

//    }

// function Tag(titleOfTag, action, attrs) {
//     this.titleOfTag = titleOfTag || 'No Title';
//     this.action = action || 'No Action';
//     this.attrs = attrs || [];
// }

    // let title = '<a>';
    // let action = 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы.';
    // let attibytes = [
    //     {titleOfAttr: 'accesskey', actionOfAttr: 'Активация ссылки с помощью комбинации клавиш.'},
    //     {titleOfAttr: 'coords', actionOfAttr: 'Устанавливает координаты активной области.'},
    //     {titleOfAttr: 'download', actionOfAttr: 'Предлагает скачать указанный по ссылке файл.'},
    // ];
    // let a = new Tag(title, action, attibytes);
    // console.log(a);

    // let title = '<div>';
    // let action = 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.';
    // let attibytes = [
    //     {titleOfAttr: 'align', actionOfAttr: 'Задает выравнивание содержимого тега <div>.'},
    //     {titleOfAttr: 'title', actionOfAttr: 'Добавляет всплывающую подсказку к содержимому.'},
    // ];
    // let div = new Tag(title, action, attibytes);
    // console.log(div);

    // let title = '<h1>';
    // let action = 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.';
    // let attibytes = [
    //     {titleOfAttr: 'align', actionOfAttr: 'Определяет выравнивание заголовка.'},
    // ];
    // let h1 = new Tag(title, action, attibytes);
    // console.log(h1);

    // let title = '<span>';
    // let action = 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.';
    // let attibytes = [
    //     {titleOfAttr: 'accesskey', actionOfAttr: 'Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.'},
    //     {titleOfAttr: 'class', actionOfAttr: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'},
    // ];
    // let span = new Tag(title, action, attibytes);
    // console.log(span);

    // let title = '<input>';
    // let action = 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.';
    // let attibytes = [
    //     {titleOfAttr: 'accesskey', actionOfAttr: 'Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.'},
    //     {titleOfAttr: 'accept', actionOfAttr: 'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.'},
    //     {titleOfAttr: 'alt', actionOfAttr: 'Альтернативный текст для кнопки с изображением.'},
    // ];
    // let input = new Tag(title, action, attibytes);
    // console.log(input);

    // let title = '<form>';
    // let action = 'Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.';
    // let attibytes = [
    //     {titleOfAttr: 'accept-charset', actionOfAttr: 'Устанавливает кодировку, в которой сервер может принимать и обрабатывать данные.'},
    //     {titleOfAttr: 'action', actionOfAttr: 'Адрес программы или документа, который обрабатывает данные формы.'},
    //     {titleOfAttr: 'autocomplete', actionOfAttr: 'Включает автозаполнение полей формы.'},
    // ];
    // let form = new Tag(title, action, attibytes);
    // console.log(form);

    // let title = '<option>';
    // let action = 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.';
    // let attibytes = [
    //     {titleOfAttr: 'disabled', actionOfAttr: 'Заблокировать для доступа элемент списка.'},
    //     {titleOfAttr: 'label', actionOfAttr: 'Указание метки пункта списка.'},
    //     {titleOfAttr: 'selected', actionOfAttr: 'Заранее устанавливает определенный пункт списка выделенным.'},
    // ];
    // let option = new Tag(title, action, attibytes);
    // console.log(option);

    // let title = '<select>';
    // let action = 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.';
    // let attibytes = [
    //     {titleOfAttr: 'accesskey', actionOfAttr: 'Заблокировать для доступа элемент списка.Позволяет перейти к списку с помощью некоторого сочетания клавиш.'},
    //     {titleOfAttr: 'autofocus', actionOfAttr: 'Устанавливает, что список получает фокус после загрузки страницы.'},
    //     {titleOfAttr: 'disabled', actionOfAttr: 'Блокирует доступ и изменение элемента.'},
    // ];
    // let select = new Tag(title, action, attibytes);
    // console.log(select);


        
        

        









    </script>







    
</body>
</html>